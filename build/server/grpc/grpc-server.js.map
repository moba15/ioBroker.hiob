{
  "version": 3,
  "sources": ["../../../src/server/grpc/grpc-server.ts"],
  "sourcesContent": ["import * as ws from \"ws\";\nimport * as fs from \"fs\";\nimport * as m from \"../..//main\";\nimport { Client } from \".././client\";\nimport * as grpc from \"@grpc/grpc-js\";\nimport * as proto from \"../../generate/proto/login/login\"\n\nclass LoginService extends proto.UnimplementedLoginService {\n    \n    \n    CheckCompatibility(call: grpc.ServerUnaryCall<proto.CompatibilityRequest, proto.CompatibilityResponse>, callback: grpc.sendUnaryData<proto.CompatibilityResponse>): void {\n        throw new Error(\"Method not implemented.\");\n    }\n    Login(call: grpc.ServerUnaryCall<proto.LoginRequest, proto.LoginResponse>, callback: grpc.sendUnaryData<proto.LoginResponse>): void {\n        throw new Error(\"Method not implemented.\");\n    }\n\n}\n\nexport class GrpcServer {\n    certPath: string;\n    keyPath: string;\n    useCert: boolean;\n    port: number;\n    adapter: m.SamartHomeHandyBis;\n    gRpcServer: grpc.Server | undefined;\n    stoped: boolean = false;\n    conClients: Client[] = [];\n    constructor(\n        port: number = 4500,\n        keyPath: string = \"key.pem\",\n        certPath: string = \"cert.pem\",\n        adapter: m.SamartHomeHandyBis,\n        useCert: boolean = false,\n    ) {\n        this.port = port;\n        this.certPath = certPath;\n        this.keyPath = keyPath;\n        this.adapter = adapter;\n        this.useCert = useCert;\n    }\n    startServer(): void {\n        this.gRpcServer = new grpc.Server();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this.gRpcServer.addService(proto.LoginClient.service, { Login: (call: grpc.ServerUnaryCall<proto.LoginRequest, proto.LoginResponse>, callback: grpc.sendUnaryData<proto.LoginResponse>) => {\n            const request : proto.LoginRequest = call.request;\n        }})\n        this.gRpcServer.bindAsync(\"0.0.0.0:\" + this.port, grpc.ServerCredentials.createInsecure(), () => {\n            this.adapter.log.info(\"Server listening on port: \" + this.port);\n        })\n    }\n\n    broadcastMsg(msg: string): void {\n        //this.webSocketServer.clients.forEach((e) => {});\n        this.conClients\n            .filter((e) => !e.onlySendNotification)\n            .forEach((element) => {\n                if (element.isConnected) element.sendMSG(msg, true);\n            });\n    }\n\n    isConnected(deviceID: string): boolean {\n        return this.conClients.some((c) => c.isConnected && c.id == deviceID);\n    }\n\n    getClient(deviceID: string): Client | undefined {\n        return this.conClients.find((c) => c.isConnected && c.id == deviceID);\n    }\n\n    stop(): void {\n   \n        this.adapter.log.info(\"Server stoped\");\n        this.stoped = true;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,WAAsB;AACtB,YAAuB;AAEvB,MAAM,qBAAqB,MAAM,0BAA0B;AAAA,EAGvD,mBAAmB,MAAqF,UAAiE;AACrK,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAAA,EACA,MAAM,MAAqE,UAAyD;AAChI,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC7C;AAEJ;AAEO,MAAM,WAAW;AAAA,EASpB,YACI,OAAe,MACf,UAAkB,WAClB,WAAmB,YACnB,SACA,UAAmB,OACrB;AARF,kBAAkB;AAClB,sBAAuB,CAAC;AAQpB,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,cAAoB;AAChB,SAAK,aAAa,IAAI,KAAK,OAAO;AAElC,SAAK,WAAW,WAAW,MAAM,YAAY,SAAS,EAAE,OAAO,CAAC,MAAqE,aAAsD;AACvL,YAAM,UAA+B,KAAK;AAAA,IAC9C,EAAC,CAAC;AACF,SAAK,WAAW,UAAU,aAAa,KAAK,MAAM,KAAK,kBAAkB,eAAe,GAAG,MAAM;AAC7F,WAAK,QAAQ,IAAI,KAAK,+BAA+B,KAAK,IAAI;AAAA,IAClE,CAAC;AAAA,EACL;AAAA,EAEA,aAAa,KAAmB;AAE5B,SAAK,WACA,OAAO,CAAC,MAAM,CAAC,EAAE,oBAAoB,EACrC,QAAQ,CAAC,YAAY;AAClB,UAAI,QAAQ;AAAa,gBAAQ,QAAQ,KAAK,IAAI;AAAA,IACtD,CAAC;AAAA,EACT;AAAA,EAEA,YAAY,UAA2B;AACnC,WAAO,KAAK,WAAW,KAAK,CAAC,MAAM,EAAE,eAAe,EAAE,MAAM,QAAQ;AAAA,EACxE;AAAA,EAEA,UAAU,UAAsC;AAC5C,WAAO,KAAK,WAAW,KAAK,CAAC,MAAM,EAAE,eAAe,EAAE,MAAM,QAAQ;AAAA,EACxE;AAAA,EAEA,OAAa;AAET,SAAK,QAAQ,IAAI,KAAK,eAAe;AACrC,SAAK,SAAS;AAAA,EAClB;AACJ;",
  "names": []
}
