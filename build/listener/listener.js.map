{
  "version": 3,
  "sources": ["../../src/listener/listener.ts"],
  "sourcesContent": ["import { EventEmitter } from \"stream\";\nimport { SamartHomeHandyBis } from \"../main\";\nimport { StateChangedDataPack } from \"../server/datapacks\";\nimport { Mutex } from \"async-mutex\";\n\nexport enum Events {\n    StateChange = \"stateChanged\",\n}\n// eslint-disable-next-line no-unused-vars \nexport class Listener extends EventEmitter {\n    static subscribtionThresholdPerInstance = 15;\n    adapter : SamartHomeHandyBis;\n    busy : boolean = false;\n    subsribedStates: Map<string, {overThreshold: boolean, subscribed: Set<string>, pending: Set<string>}> = new Map();\n    subscribedStates: Set<string> = new Set();\n    pendingSubscribeStates: Set<string> = new Set();\n    mutex : Mutex = new Mutex();\n    constructor(adapter: SamartHomeHandyBis) {\n        super();\n        this.adapter = adapter;\n    }\n\n    onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state != null) {\n            // The state was changed\n            //this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n            //Check if notification\n            if (!id.startsWith(\"hiob.\")) {\n                const adapaterKey : string = id.split(\".\")[0] + \".\" +  id.split(\".\")[1];\n                if(this.subscribedStates.has(id)) {\n                    if (this.adapter.valueDatapoints[id] == null) {\n                        this.adapter.valueDatapoints[id] = {};\n                    }\n                    this.adapter.valueDatapoints[id].val = state.val;\n                    this.adapter.valueDatapoints[id].ack = state.ack;\n                    this.adapter.server?.broadcastMsg(\n                        new StateChangedDataPack(id, state.val, state.ack, state.lc, state.ts).toJSON()\n                    );\n\n                }\n            }\n            this.emit(Events.StateChange, new StateChangeEvent(id, state.val, state.ack));\n            this.emit(Events.StateChange + id, new StateChangeEvent(id, state.val, state.ack));\n        } else {\n            this.emit(\"stateDeleted\", new StateChangeEvent(id, null, null));\n            this.adapter.log.info(`state ${id} deleted`);\n        }\n    }\n    /**\n     * Adds a State id to the pending list\n     * @param id The id of the State you want to subscribe to\n     */\n    addPendingSubscribeState(id: string) : void {\n       this.mutex.runExclusive(async () => {\n        if(this.subscribedStates.has(id)) {\n            return;\n        }\n        this.pendingSubscribeStates.add(id);\n        const adapaterKey : string = id.split(\".\")[0] + \".\" +  id.split(\".\")[1];\n        if(this.subsribedStates.has(adapaterKey)) {\n            const t = this.subsribedStates.get(adapaterKey);\n            if(!t!.subscribed.has(id)) {\n                t?.pending.add(id);\n            } else {\n                this.adapter.log.debug(\"Already has subscribed to \" + id + \"!\");\n            }\n        } else {\n            this.subsribedStates.set(adapaterKey, {overThreshold: false, subscribed: new Set(), pending:  new Set([id])});\n        }\n       });\n    }\n    /**\n     * Subscribes to all States listed in the pending (see addPendingSubscribeState)\n     * If there are more than 50 subscriptions for one instance it subscribses to all changes inside this instance\n     */\n    subscribeToPendingStates() : void{\n        this.mutex.runExclusive(async () => {\n            if(this.subscribedStates.size >=  Listener.subscribtionThresholdPerInstance) {\n                this.pendingSubscribeStates.forEach((e) => this.subscribedStates.add(e));\n                this.pendingSubscribeStates.clear();\n            } else {\n               /* if(this.subscribedStates.size + this.pendingSubscribeStates.size >= Listener.subscribtionThresholdPerInstance) {\n                    this.adapter.log.debug(\"More than 50 states. Subscribing to *\")\n                    await this.adapter.subscribeForeignStatesAsync(\"*\");\n                    this.subscribedStates.forEach((e) => this.adapter.unsubscribeForeignStatesAsync(e));\n                    this.pendingSubscribeStates.forEach((e) => this.subscribedStates.add(e));\n                } else {\n                    this.pendingSubscribeStates.forEach((e) => this.adapter.subscribeForeignStatesAsync(e));\n                }\n                this.pendingSubscribeStates.clear();*/\n            \n            for(const [adapaterKey, subsribedStatesStatus] of this.subsribedStates) {\n                if(subsribedStatesStatus.pending.size > 0) {\n                    if(subsribedStatesStatus.overThreshold) {\n                        subsribedStatesStatus.pending.forEach((e) => subsribedStatesStatus.subscribed.add(e));\n                    } else {\n                        const newSubscriptionSize = subsribedStatesStatus.pending.size + subsribedStatesStatus.subscribed.size;\n                        if(newSubscriptionSize >  Listener.subscribtionThresholdPerInstance && !adapaterKey.startsWith(\"alias.\")) {\n                            subsribedStatesStatus.pending.forEach((e) => {\n                                subsribedStatesStatus.subscribed.add(e);\n                            });\n                            this.adapter.log.debug(\"More than \" + Listener.subscribtionThresholdPerInstance + \" states of \" + adapaterKey + \" were subscribed. Now only listening to \" + adapaterKey + \".*\");\n                            //subscribe to * instead\n                            await this.adapter.subscribeForeignStatesAsync(adapaterKey + \".*\");\n                            //Unsubscribe to the exesting subscriptions\n                            for(const i of subsribedStatesStatus.subscribed) {\n                                this.adapter.unsubscribeForeignStatesAsync(i);\n                            }\n                        } else {\n                            subsribedStatesStatus.pending.forEach((e) => {\n                                subsribedStatesStatus.subscribed.add(e);\n                                this.adapter.subscribeForeignStates(e);\n                            });\n                        }\n                    }\n                    subsribedStatesStatus.pending.clear();\n                }\n            }\n        }\n        });\n    }\n}\n\nexport class StateChangeEvent {\n    objectID: string;\n    value: any;\n    ack: any;\n    constructor(\n        objectID: string,\n        value: string | number | boolean | undefined | null,\n        ack: boolean | undefined | null,\n    ) {\n        this.objectID = objectID;\n        this.value = value;\n        this.ack = ack;\n    }\n}\n"],
  "mappings": "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",
  "names": ["Events"]
}
