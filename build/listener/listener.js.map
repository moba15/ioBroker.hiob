{
  "version": 3,
  "sources": ["../../src/listener/listener.ts"],
  "sourcesContent": ["import { EventEmitter } from \"stream\";\nimport { SamartHomeHandyBis } from \"../main\";\nimport { StateChangedDataPack } from \"../server/datapacks\";\nimport { Mutex } from \"async-mutex\";\nimport * as proto from \"../generated/state/state\";\nimport { ServerWritableStream } from \"@grpc/grpc-js\";\n\nexport enum Events {\n    StateChange = \"stateChanged\",\n}\n// eslint-disable-next-line no-unused-vars \nexport class Listener extends EventEmitter {\n    static subscribtionThresholdPerInstance = 15;\n    adapter : SamartHomeHandyBis;\n    busy : boolean = false;\n    subsribedStates: Map<string, {overThreshold: boolean, subscribed: Set<string>, pending: Set<string>}> = new Map();\n    //subscribedStates: Set<string> = new Set();\n    pendingSubscribeStates: Set<string> = new Set();\n    mutex : Mutex = new Mutex();\n    subscribedWritersMutex : Mutex = new Mutex();\n    subscribedWriters: {device: string, writer: ServerWritableStream<proto.StateSubscribtion, proto.StatesValueUpdate>}[] = [];\n    constructor(adapter: SamartHomeHandyBis) {\n        super();\n        this.adapter = adapter;\n    }\n\n    onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        this.adapter.log.debug(\"Send\" + JSON.stringify(this.pendingSubscribeStates));\n        if (state != null) {\n            // The state was changed\n            //this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n            //Check if notification\n            if (!id.startsWith(\"hiob.\")) {\n                const adapaterKey : string = id.split(\".\")[0] + \".\" +  id.split(\".\")[1];\n                if(this.subsribedStates.has(adapaterKey) && this.subsribedStates.get(adapaterKey)?.subscribed.has(id)) {\n                    if (this.adapter.valueDatapoints[id] == null) {\n                        this.adapter.valueDatapoints[id] = {};\n                    }\n                    this.adapter.valueDatapoints[id].val = state.val;\n                    this.adapter.valueDatapoints[id].ack = state.ack;\n                    this.adapter.server?.broadcastMsg(\n                        new StateChangedDataPack(id, state.val, state.ack, state.lc, state.ts).toJSON()\n                    );\n                    const stateValueUpdate = new proto.StateValueUpdate({stateId: id, acc: state.ack, stringValue: state.val?.toString(), time: state.ts});\n                    this.subscribedWriters.forEach((e) => e.writer.write(new proto.StatesValueUpdate({stateUpdates: [stateValueUpdate]})))\n\n                }\n            }\n            this.emit(Events.StateChange, new StateChangeEvent(id, state.val, state.ack));\n            this.emit(Events.StateChange + id, new StateChangeEvent(id, state.val, state.ack));\n        } else {\n            this.emit(\"stateDeleted\", new StateChangeEvent(id, null, null));\n            this.adapter.log.info(`state ${id} deleted`);\n        }\n    }\n    /**\n     * Adds a State id to the pending list\n     * @param id The id of the State you want to subscribe to\n     */\n    addPendingSubscribeState(id: string) : void {\n       this.mutex.runExclusive(async () => {\n        this.pendingSubscribeStates.add(id);\n        const adapaterKey : string = id.split(\".\")[0] + \".\" +  id.split(\".\")[1];\n        if(this.subsribedStates.has(adapaterKey)) {\n            const t = this.subsribedStates.get(adapaterKey);\n            if(!t!.subscribed.has(id)) {\n                t?.pending.add(id);\n            } else {\n                this.adapter.log.debug(\"Already has subscribed to \" + id + \"!\");\n            }\n        } else {\n            this.subsribedStates.set(adapaterKey, {overThreshold: false, subscribed: new Set(), pending:  new Set([id])});\n        }\n       });\n    }\n    /**\n     * Subscribes to all States listed in the pending (see addPendingSubscribeState)\n     * If there are more than 50 subscriptions for one instance it subscribses to all changes inside this instance\n     */\n    subscribeToPendingStates() : void {\n        this.mutex.runExclusive(async () => {\n            \n               /* if(this.subscribedStates.size + this.pendingSubscribeStates.size >= Listener.subscribtionThresholdPerInstance) {\n                    this.adapter.log.debug(\"More than 50 states. Subscribing to *\")\n                    await this.adapter.subscribeForeignStatesAsync(\"*\");\n                    this.subscribedStates.forEach((e) => this.adapter.unsubscribeForeignStatesAsync(e));\n                    this.pendingSubscribeStates.forEach((e) => this.subscribedStates.add(e));\n                } else {\n                    this.pendingSubscribeStates.forEach((e) => this.adapter.subscribeForeignStatesAsync(e));\n                }\n                this.pendingSubscribeStates.clear();*/\n            for(const [adapaterKey, subsribedStatesStatus] of this.subsribedStates) {\n                if(subsribedStatesStatus.pending.size > 0) {\n                    if(subsribedStatesStatus.overThreshold) {\n                        subsribedStatesStatus.pending.forEach((e) => subsribedStatesStatus.subscribed.add(e));\n                    } else {\n                        const newSubscriptionSize = subsribedStatesStatus.pending.size + subsribedStatesStatus.subscribed.size;\n                        if(newSubscriptionSize >  Listener.subscribtionThresholdPerInstance && !adapaterKey.startsWith(\"alias.\")) {\n                            subsribedStatesStatus.pending.forEach((e) => {\n                                subsribedStatesStatus.subscribed.add(e);\n                            });\n                            this.adapter.log.debug(\"More than \" + Listener.subscribtionThresholdPerInstance + \" states of \" + adapaterKey + \" were subscribed. Now only listening to \" + adapaterKey + \".*\");\n                            //subscribe to * instead\n                            await this.adapter.subscribeForeignStatesAsync(adapaterKey + \".*\");\n                            //Unsubscribe to the exesting subscriptions\n                            for(const i of subsribedStatesStatus.subscribed) {\n                                this.adapter.unsubscribeForeignStatesAsync(i);\n                            }\n                        } else {\n                            subsribedStatesStatus.pending.forEach((e) => {\n                                subsribedStatesStatus.subscribed.add(e);\n                                this.adapter.subscribeForeignStates(e);\n                            });\n                        }\n                    }\n                    subsribedStatesStatus.pending.clear();\n                }\n            }\n        });\n    }\n\n    addWriter(device: string, writer: ServerWritableStream<proto.StateSubscribtion, proto.StatesValueUpdate>) : void {\n        this.subscribedWritersMutex.runExclusive(() => {\n            this.subscribedWriters.push({\n                device: device,\n                writer: writer\n            });\n        });\n    }\n\n    removeWriter(device: string) : void {\n        this.subscribedWritersMutex.runExclusive(() => {\n            this.subscribedWriters = this.subscribedWriters.filter((v) => v.device == device);\n        });\n    }\n}\n\nexport class StateChangeEvent {\n    objectID: string;\n    value: any;\n    ack: any;\n    constructor(\n        objectID: string,\n        value: string | number | boolean | undefined | null,\n        ack: boolean | undefined | null,\n    ) {\n        this.objectID = objectID;\n        this.value = value;\n        this.ack = ack;\n    }\n}\n"],
  "mappings": "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",
  "names": ["Events"]
}
